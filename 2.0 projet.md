# Plan d'Action pour PastScreen 2.0

Ce document détaille le plan de développement pour la version 2.0 de PastScreen, incluant des améliorations structurelles (refactoring) et l'ajout de nouvelles fonctionnalités majeures.

---

## Phase 1 : Refactoring et Amélioration de la Base de Code

L'objectif de cette phase est de solidifier l'architecture de l'application pour la rendre plus modulaire, plus facile à maintenir et testable.

### Tâche 1 : Centralisation de la Gestion des Raccourcis Clavier

**Objectif :** Déplacer toute la logique des raccourcis clavier hors de `AppDelegate` pour la placer dans une classe dédiée.

**Étapes :**
1.  **Créer le fichier :** `PastScreen/PastScreen/Services/HotKeyManager.swift`.
2.  **Définir la classe `HotKeyManager` :**
    *   Elle contiendra les propriétés pour le moniteur d'événements (`globalEventMonitor`).
    *   Elle exposera des méthodes `startMonitoring()` et `stopMonitoring()`.
3.  **Migrer la logique de `AppDelegate` :**
    *   Déplacer les fonctions `setupGlobalHotkey()` et `removeGlobalHotkey()` de `AppDelegate` vers `HotKeyManager`.
    *   La logique de détection des touches (`NSEvent.addGlobalMonitorForEvents`) sera entièrement contenue dans le `HotKeyManager`.
4.  **Communication par Notifications :**
    *   Lorsque le raccourci est détecté, `HotKeyManager` ne déclenchera plus directement la capture. À la place, il postera une notification via `NotificationCenter`, par exemple `Notification.Name("hotKeyPressed")`.
5.  **Intégration dans `AppDelegate` :**
    *   `AppDelegate` instanciera `let hotKeyManager = HotKeyManager()`.
    *   Dans `applicationDidFinishLaunching`, `AppDelegate` appellera `hotKeyManager.startMonitoring()`.
    *   `AppDelegate` s'abonnera à la notification `hotKeyPressed` pour ensuite déclencher la capture d'écran.
    *   L'observation des `AppSettings` (`settings.$globalHotkeyEnabled`) sera aussi déplacée dans le `HotKeyManager`.

### Tâche 2 : Renforcer le `PermissionManager`

**Objectif :** Centraliser et simplifier la gestion de toutes les permissions système.

**Étapes :**
1.  **Consolider le fichier :** `PastScreen/PastScreen/Services/PermissionManager.swift`.
2.  **Créer des méthodes publiques claires :**
    *   `func checkAllPermissions()` : Vérifie le statut de toutes les permissions requises.
    *   `func requestAccessibilityPermission(completion: @escaping (Bool) -> Void)`
    *   `func requestScreenRecordingPermission(completion: @escaping (Bool) -> Void)`
    *   `var hasAllPermissions: Bool` : Une propriété calculée pour un accès rapide.
3.  **Gestion des alertes :**
    *   Créer une méthode privée `showPermissionAlert(for permission: PermissionType)` pour afficher une alerte standardisée expliquant pourquoi la permission est nécessaire et comment l'activer.
4.  **Refactoriser l'utilisation :**
    *   Remplacer tous les appels directs à `AXIsProcessTrusted()` dans `AppDelegate` et ailleurs par des appels aux méthodes du `PermissionManager.shared`.

### Tâche 3 : Mettre en Place des Tests Unitaires

**Objectif :** Créer une fondation de tests pour garantir la stabilité de l'application.

**Étapes :**
1.  **Configurer la Cible de Test :** Assurer que le projet Xcode a une cible `PastScreenTests`.
2.  **Tester les `AppSettings` :**
    *   Écrire des tests pour `AppSettings.swift`.
    *   Valider que les valeurs par défaut sont correctement définies.
    *   Valider que la modification d'un paramètre le sauvegarde bien dans `UserDefaults`.
3.  **Tester les Utilitaires :**
    *   Écrire des tests pour les fonctions pures (qui ne dépendent pas de l'UI ou du système), comme la logique de formatage des noms de fichiers dans `ScreenshotService`.

---

## Phase 2 : Développement de Nouvelles Fonctionnalités

Une fois la base de code assainie, nous pourrons ajouter de nouvelles fonctionnalités de manière plus efficace.

### Tâche 4 : Historique des Captures d'Écran

**Objectif :** Permettre aux utilisateurs d'accéder rapidement aux dernières captures.

**Étapes :**
1.  **Modèle de Données :**
    *   Dans `AppSettings`, ajouter une propriété `@Published var captureHistory: [String] = []` qui stockera les chemins des 10 dernières captures.
    *   Cette propriété sera persistée dans `UserDefaults`.
2.  **Mise à jour de l'historique :**
    *   Dans `ScreenshotService`, après chaque sauvegarde de fichier réussie, ajouter le chemin à `AppSettings.shared.captureHistory`. La liste sera limitée aux 10 derniers éléments.
3.  **Interface Utilisateur :**
    *   Dans `AppDelegate`, modifier `createMenu()` pour ajouter un `NSMenuItem` "Historique".
    *   Ce menu contiendra un sous-menu généré dynamiquement à partir de `AppSettings.shared.captureHistory`.
    *   Chaque élément du sous-menu affichera un aperçu du nom de fichier (`Screenshot-2023-10-27...`) et, au clic, copiera l'image correspondante dans le presse-papiers.

### Tâche 5 : Personnalisation des Raccourcis Clavier

**Objectif :** Laisser l'utilisateur choisir son propre raccourci pour la capture.

**Étapes :**
1.  **Modèle de Données :**
    *   Ajouter des propriétés à `AppSettings` pour stocker le `keyCode` et les `modifierFlags` du raccourci.
2.  **Interface de Configuration :**
    *   Dans `SettingsView.swift`, sous l'onglet "Capture", créer un composant UI dédié.
    *   Ce composant affichera le raccourci actuel et un bouton "Modifier". Au clic, il capturera la prochaine combinaison de touches pressée par l'utilisateur.
3.  **Mise à jour du `HotKeyManager` :**
    *   Le `HotKeyManager` lira désormais le raccourci à partir des `AppSettings` au lieu d'utiliser une valeur codée en dur (`⌥⌘S`).
    *   Il devra aussi s'abonner aux changements de ces nouvelles propriétés pour mettre à jour le moniteur d'événements à la volée.

### Tâche 6 : Reconnaissance de Texte (OCR)

**Objectif :** Extraire et copier le texte présent dans une capture d'écran.

**Étapes :**
1.  **Intégration du Framework `Vision` :**
    *   Ajouter `import Vision` dans `ScreenshotService.swift`.
2.  **Créer la fonction d'extraction :**
    *   Créer une nouvelle méthode `performTextRecognition(on cgImage: CGImage) async -> String?`.
    *   À l'intérieur, utiliser `VNImageRequestHandler` et `VNRecognizeTextRequest` pour traiter l'image.
    *   Concaténer les résultats pour former une seule chaîne de caractères.
3.  **Intégration dans le flux de capture :**
    *   Après une capture réussie, la `CGImage` est disponible.
    *   Ajouter un nouvel item "Copier le Texte" dans le menu de la barre de statut.
    *   Lors du clic, appeler la fonction d'OCR et copier le résultat dans le presse-papiers.
    *   Optionnellement, ajouter un bouton à la notification de succès.

### Tâche 7 : Outils d'Annotation Rapide

**Objectif :** Permettre des modifications simples (flèches, rectangles, floutage) juste après la capture.

**Étapes (complexité élevée) :**
1.  **Fenêtre d'Annotation :**
    *   Après la capture, au lieu de copier/sauvegarder immédiatement, afficher une nouvelle fenêtre (ou une surcouche sur l'écran) avec l'image capturée.
2.  **Barre d'outils :**
    *   Cette fenêtre contiendra une petite barre d'outils avec des options : flèche, rectangle, texte, flou, etc.
3.  **Logique de Dessin :**
    *   Implémenter la logique pour dessiner ces annotations par-dessus l'image en utilisant `Core Graphics` ou `SwiftUI`.
4.  **Finalisation :**
    *   Ajouter des boutons "Copier", "Sauvegarder" et "Annuler".
    *   L'action finale (copier/sauvegarder) utilisera l'image avec les annotations appliquées.